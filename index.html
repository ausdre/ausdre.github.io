<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Le Canvas.</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&family=Sora:wght@300..800&family=Outfit:wght@300..800&family=Plus+Jakarta+Sans:ital,wght@0,300..800;1,300..800&family=Manrope:wght@300..800&family=Inter+Tight:wght@300..800&family=Work+Sans:wght@300..800&family=Atkinson+Hyperlegible:wght@200..900&family=League+Spartan:wght@400..800&family=Bebas+Neue&display=swap"
          rel="stylesheet">


    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Orbitron:wght@700;900&display=swap"
          rel="stylesheet">

    <!-- Tailwind for landing -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        ::-webkit-scrollbar {width: 10px;}
        ::-webkit-scrollbar-thumb {background: linear-gradient(180deg, #030519 28%, rgba(1, 13, 40, 0) 100%);}
        ::-webkit-scrollbar-track {background-color: #ffffff;}


        .loader {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 14.6rem;
            margin-top: 7.3rem;
            margin-bottom: 7.3rem;
            }
        .loader:before, .loader:after {
            content: "";
            position: absolute;
            border-radius: 50%;
            animation-duration: 1.8s;
            animation-iteration-count: infinite;
            animation-timing-function: ease-in-out;
            filter: drop-shadow(0 0 0.7555555556rem rgba(255, 255, 255, 0.75));
            }
        .loader:before {
            width: 100%;
            padding-bottom: 100%;
            box-shadow: inset 0 0 0 1.7rem #fff;
            animation-name: pulsA;
            }
        .loader:after {
            width: calc(100% - 1.7rem*2);
            padding-bottom: calc(100% - 1.7rem*2);
            box-shadow: 0 0 0 0 #fff;
            animation-name: pulsB;
            }

        @keyframes pulsA {
            0% {
                box-shadow: inset 0 0 0 1.7rem #fff;
                opacity: 1;
                }
            50%, 100% {
                box-shadow: inset 0 0 0 0 #fff;
                opacity: 0;
                }
            }
        @keyframes pulsB {
            0%, 50% {
                box-shadow: 0 0 0 0 #fff;
                opacity: 0;
                }
            100% {
                box-shadow: 0 0 0 1.7rem #fff;
                opacity: 1;
                }
            }

        body,html,#root {
            margin:                  0;
            padding:                 0;
            width:                   100%;
            font-size:               16px;
            line-height:             150%;
            text-rendering:          optimizeLegibility;
            font-feature-settings:   "liga", "kern", "ss01";
            -webkit-font-smoothing:  subpixel-antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow:              hidden;
            cursor: none                  ;
            }


        /* prevent margin-collapsing from breaking the snap */
        .section-immersive {min-height: 100vh;}


        .R3FHeader {
            width: 100%;
            height: 100vh; /* header height */
            display: flex;
            background: #030519;
            transition: background 1s;
            position: relative; /* anchor for ::after and Title */
            }

        /*#root::after {
          pointer-events: none;
          content: '';
          position: absolute;
          z-index: 1;
          left: 0;
          right: 0;
          top: calc(100vh - 100px);
          height: 100px;
          transition: background 1s;
          background: linear-gradient(0deg, #030519 28%, rgba(1, 13, 40, 0) 100%);
        }*/


        .TitleContainer {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 3;
            perspective: 600px;
            }


        .TitleHome {
            position: relative;
            min-width: 25vw;
            max-width: 75vw;
            margin: auto;
            text-shadow: 1px 2px 2px #3d3d3d;
            color: #ffffff;
            text-align: center;
            font-family: "Sora", system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: 300;
            letter-spacing: -0.055em;
            /* word-spacing: 1rem; */
            font-size: clamp(33px, 3vw, 55px);
            line-height: 110%;
            transform-style: preserve-3d;
            backface-visibility: visible;
            -webkit-backface-visibility: visible;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            font-feature-settings: "liga", "kern", "ss01";
            }


        /* Title animation */
        .swing-in-right-fwd {
            -webkit-animation: swing-in-right-fwd .5s cubic-bezier(1.000, 0.000, 0.000, 1.000) both;
            animation: swing-in-right-fwd .5s cubic-bezier(1.000, 0.000, 0.000, 1.000) both
            }

        @-webkit-keyframes swing-in-right-fwd {
            0% {
                -webkit-transform: rotateY(-100deg);
                transform: rotateY(-100deg);
                -webkit-transform-origin: right;
                transform-origin: right;
                opacity: 0
                }

            100% {
                -webkit-transform: rotateY(0);
                transform: rotateY(0);
                -webkit-transform-origin: right;
                transform-origin: right;
                opacity: 1
                }
            }

        @keyframes swing-in-right-fwd {
            0% {
                transform: rotateY(-100deg);
                transform-origin: right;
                opacity: 0
                }

            100% {
                transform: rotateY(0);
                transform-origin: right;
                opacity: 1
                }
            }



        .vaeora-logo-svg { max-width: 10vw; }


        /* Intro overlay transition */
        #intro-overlay {
            transition: opacity .7s, filter .7s, transform .7s;
            }

        #brand-left {
            position: fixed;
            top: 4rem;
            left: 4rem;
            z-index: 60;
            line-height: 0;
            }


        #brand-left .vaeora-wordmark { filter: none; transition: filter .77s ease-in-out; }
        #brand-left.invertV .vaeora-wordmark { filter: invert(1); }

        .invertMe { filter: invert(1); }


        /* ensure header + sections fill a viewport */
        #root {
            min-height: 100vh;
            }

        /* parent of the header */
        .R3FHeader {
            height: 100vh;
            }


        /* replace margins with padding inside */

        @media (max-width: 700px) {
            .TitleHome {
                font-size: clamp(24px, 2.5vw, 55px);
                }

            .vaeora-logo-svg {
                width: 25vw;
                height: auto;
                }

            #nav-overlay a {font-size: 2rem;}
            }
    </style>
    <!--
    Fonts available

    Space Grotesk
    Sora
    Outfit
    Plus Jakarta Sans
    Manrope
    Inter
    Inter Tight
    Work Sans
    Atkinson Hyperlegible
    League Spartan
    Bebas Neue
    Orbitron

    -->
    <!-- React/R3F import map from original ref.html -->
    <script type="importmap">
        {
            "imports": {
              "react": "https://esm.sh/react@18.2.0",
              "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
              "three": "https://esm.sh/three@0.158.0",
              "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?deps=react@18.2.0,react-dom@18.2.0,three@0.158.0",
              "animejs": "https://esm.sh/animejs@3.2.1",
              "pako": "https://esm.sh/pako@2.1.0",
              "react-intl": "https://esm.sh/react-intl@6.6.6?deps=react@18.2.0",
              "@react-spring/web": "https://esm.sh/@react-spring/web@9.7.3?deps=react@18.2.0,react-dom@18.2.0"
            }
          }
    </script>
</head>

<body>
<!--<div id="custom-pointer"></div>-->
<div id="intro-overlay" style="position:fixed;inset:0;z-index:110;display:flex;align-items:center;justify-content:center;background:#030519;"><div class="loader"></div></div>
<div id="page">
    <!-- R3F header -->
    <div id="root"></div>
</div>
<!-- background canvas -->
<script type="module">
  /* === Libs === */
  import React from 'react';
  import { createRoot } from 'react-dom/client';
  import * as THREE from 'three';
  import { Canvas, useFrame, useThree } from '@react-three/fiber';
  import anime from 'animejs';
  import { ungzip } from 'pako';
  import { IntlProvider, injectIntl } from 'react-intl';
  import { useTransition, animated } from '@react-spring/web';
  import { MESSAGES } from "./messages.js";

  /* ================= Core constants / helpers ================= */
  const browser = (()=>{var u=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var O=Object.prototype.hasOwnProperty;var B=(r,e)=>{for(var n in e)u(r,n,{get:e[n],enumerable:!0})},x=(r,e,n,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of W(e))!O.call(r,o)&&o!==n&&u(r,o,{get:()=>e[o],enumerable:!(i=b(e,o))||i.enumerable});return r};var A=r=>x(u({},"__esModule",{value:!0}),r);var k={};B(k,{BotInfo:()=>l,BrowserInfo:()=>v,NodeInfo:()=>h,ReactNativeInfo:()=>p,SearchBotDeviceInfo:()=>w,browserName:()=>I,detect:()=>R,detectOS:()=>S,getNodeVersion:()=>g,parseUserAgent:()=>d});var N=function(){for(var r=0,e=0,n=arguments.length;e<n;e++)r+=arguments[e].length;for(var i=Array(r),o=0,e=0;e<n;e++)for(var t=arguments[e],s=0,a=t.length;s<a;s++,o++)i[o]=t[s];return i},v=(function(){function r(e,n,i){this.name=e,this.version=n,this.os=i,this.type="browser"}return r})();var h=(function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r})();var w=(function(){function r(e,n,i,o){this.name=e,this.version=n,this.os=i,this.bot=o,this.type="bot-device"}return r})();var l=(function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r})();var p=(function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r})();var y=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,_=/(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,c=3,E=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/Edg\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FBAV\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["searchbot",y]],f=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function R(r){return r?d(r):typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new p:typeof navigator<"u"?d(navigator.userAgent):g()}function m(r){return r!==""&&E.reduce(function(e,n){var i=n[0],o=n[1];if(e)return e;var t=o.exec(r);return!!t&&[i,t]},!1)}function I(r){var e=m(r);return e?e[0]:null}function d(r){var e=m(r);if(!e)return null;var n=e[0],i=e[1];if(n==="searchbot")return new l;var o=i[1]&&i[1].split(/[._]/).slice(0,3);o?o.length<c&&(o=N(o,M(c-o.length))):o=[];var t=o.join("."),s=S(r),a=_.exec(r);return a&&a[1]?new w(n,t,s,a[1]):new v(n,t,s)}function S(r){for(var e=0,n=f.length;e<n;e++){var i=f[e],o=i[0],t=i[1],s=t.exec(r);if(s)return o}return null}function g(){var r=typeof process<"u"&&process.version;return r?new h(process.version.slice(1)):null}function M(r){for(var e=[],n=0;n<r;n++)e.push("0");return e}return A(k);})().detect();
  const isMobile = browser && (browser.os === 'iOS' || browser.os === 'Android') // /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');

  const BASE_W = 2560, BASE_H = 1361;
  const BACKG = ['#030519', '#120319', '#031419'];

  const ratio = Math.max(innerWidth / BASE_W, innerHeight / BASE_H);
  const xRatio = innerWidth / BASE_W;
  const yRatio = innerHeight / BASE_H;

  const NODE_PX = isMobile ? 0.9 : 1;
  const FOV = 75;
  const CAMERA_FAR = 9000;
  const CAMERA_NEAR = 0.1;

  /* Edge-Breiten-Konfiguration:
     - Wir speichern die gewünschte Breite in Pixeln in state.edgeWidthPx (siehe Scene).
     - Umrechnung in Clip-Space (Shader erwartet „width“ in Clip-Koordinaten):
       1 px ≈ 2/1080 Clip (Y wird im Shader auf 1080 „fixiert“, dadurch viewport-stabil).
     - EDGE_PX_BASE = „dünn“, EDGE_PX_EMPH = „betont“ (Steps 3 & 6).
  */
  const edgeClipFromPx = (px) => (px * 2.0) / 1080.0;
  const EDGE_PX_BASE = isMobile ? 14 : 18; // Grunddicke (sichtbar, aber dezent)
  const EDGE_PX_EMPH = isMobile ? 55 : 70; // betont (Steps 3 & 6)


  const layouts = {
    circle: { axis1: { step: 10, min: 0, max: 720, values: [0, 360] }, axis2: { step: 10, min: 0, max: 1000, values: [100, 500] }, axis3: { step: 5, min: -600, max: 600, values: [-300, 300] } },
    grid: { axis1: { step: 10, min: -1000, max: 1000, values: [-500, 500] }, axis2: { step: 10, min: -1000, max: 1000, values: [-300, 300] }, axis3: { step: 5, min: -600, max: 600, values: [-300, 300] } },
    forceLayout: {},
    coral: { axis1: { step: 10, min: 0, max: 720, values: [0, 360] }, axis2: { step: 10, min: 0, max: 1000, values: [100, 500] }, axis3: { step: 5, min: -600, max: 600, values: [-300, 300] } }
  };

  /* layout -> link family */
  const linksKeyForLayout = l => (l === 'coral' || l === 'WDMTG') ? 'hierarchyRelation' : (l === 'forceLayout') ? 'logicLinks' : 'getLinks';

  function setBG(color) {
    const r3fHeader = document.getElementsByClassName('R3FHeader')[0]
    const rootEl = document.getElementById('root');
    if (rootEl) rootEl.style.background = color;
    if (r3fHeader) r3fHeader.style.background = `linear-gradient(180deg, ${color} 28%, rgba(1,13,40,0) 100%)`;
  }

  function pxToWorld(px, camZ, fovDeg, viewportH) {
    const f = Math.tan(THREE.MathUtils.degToRad(fovDeg * 0.5)) * 2;
    return px * camZ * f / viewportH;
  }

  function dedupeLinks(list) {
    const s = new Set(),
        out = [];
    for (const { from, to } of list || []) {
      const a = Math.min(from, to),
          b = Math.max(from, to),
          k = `${a}-${b}`;
      if (!s.has(k)) {
        s.add(k);
        out.push({ from: a, to: b });
      }
    }
    return out;
  }

  function webglOK() {
    try { const c = document.createElement('canvas'); return !!(c.getContext('webgl') || c.getContext('experimental-webgl')); } catch { return false; }
  }

  function TitleBase({ current }) {
    const ref = React.useRef(null);
    const [text, setText] = React.useState("");

    React.useEffect(() => {
      // Array ist 0-basiert, current vermutlich 1-basiert → -1
      const newText = MESSAGES[current - 1] || "";
      setText(newText);

      const el = ref.current;
      if (!el) return;
      el.classList.remove("swing-in-right-fwd");
      void el.offsetWidth; // force reflow
      el.classList.add("swing-in-right-fwd");
    }, [current]);

    return React.createElement(
        "div",
        { className: "TitleContainer" },
        React.createElement("div", {
          ref,
          className: "TitleHome swing-in-right-fwd",
          dangerouslySetInnerHTML: { __html: text }
        })
    );
  }

  const Title = TitleBase;

  const edgeShader = {
    transparent: true,
    depthTest: false,
    depthWrite: false,
    uniforms: {
      opacity: { value: 0.005 }, // wird pro Step gesetzt
      width: { value: edgeClipFromPx(EDGE_PX_EMPH) }, // wird pro Frame aus state.edgeWidthPx gespiegelt
      resolution: { value: new THREE.Vector2(1920, 1080) }
    },
    vertexShader: `#define PI 3.1415926535897932384626433832795
    precision highp float;

    uniform vec2 resolution;
    uniform float opacity;
    uniform float width;

    attribute vec3 instanceFrom;
    attribute vec3 instanceTo;

    varying vec3 vColor;
    varying float vOpacity;
    varying float vDistance;

    float atan2(in float y, in float x)
    {
        return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);
    }

    void main() {
      vec2 r = vec2(resolution.x, 1080);
      float linewidth = width;
      float aspect = r.x / r.y;

      vec4 start = modelViewMatrix * vec4( instanceFrom, 1.0 );
      vec4 end = modelViewMatrix * vec4( instanceTo, 1.0 );

      vec4 clipStart = projectionMatrix * start;
      vec4 clipEnd = projectionMatrix * end;

      vec2 ndcStart = clipStart.xy / clipStart.w;
      vec2 ndcEnd = clipEnd.xy / clipEnd.w;

      // direction
      vec2 dir = ndcEnd - ndcStart;

      // account for clip-space aspect ratio
      dir.x *= aspect;
      dir = normalize( dir );

      // perpendicular to dir
      vec2 offset = vec2( dir.y, - dir.x );

      // undo aspect ratio adjustment
      dir.x /= aspect;
      offset.x /= aspect;

      // sign flip
      if ( position.x < 0.0 ) offset *= - 1.0;

      // endcaps
      if ( position.y < 0.0 ) {
        offset += - dir;
      } else if ( position.y > 1.0 ) {
        offset += dir;
      }

      // adjust for linewidth
      offset *= linewidth;

      // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
      // offset /= resolution.y;

      // select end
      vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

      // back to clip space
      // offset *= clip.w;

      clip.xy += offset;
      vOpacity = opacity;

      gl_Position = clip;
    }`,
    fragmentShader: `precision highp float;
    varying float vOpacity;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, vOpacity);
    }`,
  };
  const nodeShader = {
    transparent: true,
    depthTest: true,
    depthWrite: true,
    uniforms: { paillette: { value: 0 } },
    vertexShader: `precision highp float;
    uniform float paillette;

    attribute vec3 instancePosition;
    attribute vec3 instanceColor;
    attribute float instanceScale;
    attribute float instanceOpacity;

    varying vec3 vColor;
    varying float vOpacity;

    void main() {
      // world matrix * instance position = world position
      vec4 mvPosition = modelViewMatrix * vec4(instancePosition, 1.0);

      // add scale
      mvPosition.xyz += position * instanceScale;

      // compute instance position from camera
      gl_Position = projectionMatrix * mvPosition;

      vColor = instanceColor + (vec3(1.0, 1.0 ,1.0) * (cos(instanceOpacity + paillette) * 0.1));
      if (instanceOpacity == 1.0) {
        vOpacity = 0.8 + cos(instanceOpacity + paillette) * 0.2;
      } else {
        vOpacity = instanceOpacity;
      }
    }`,
    fragmentShader: `precision highp float;
    varying vec3 vColor;
    varying float vOpacity;

    void main() {
      gl_FragColor = vec4(vColor, vOpacity);
      // gl_FragColor.a *= ((1.0 - pow( gl_FragCoord.z, 10000.0 )));
    }`,
  };

  /* ================= Load data + global centering ================= */
  /* ---------- robust loader: multi-frame + append single-frame ---------- */
  async function loadFramesAndLinks() {
    // small helper that returns null on failure (404/network/etc.)
    async function safeLoadGZJSON(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return null;
        const a = await r.arrayBuffer();
        return JSON.parse(ungzip(new Uint8Array(a), { to: 'string' }));
      } catch (_) {
        console.warn(_.message, url)
        return null;
      }
    }

    const frames = [];

    const pts = await safeLoadGZJSON('./points_w_ratio.json.gz');
    if (Array.isArray(pts) && pts.length) {
      // (legacy mobile tweak kept exactly as before)
      if ((innerWidth || innerHeight) <= 600 && pts[5] && pts[5][0]) {
        const A = Array.isArray(pts[5][0]) ? pts[5][0] : Object.values(pts[5][0]);
        for (let i = 0; i < A.length; i += 3) {
          const x = A[i];
          A[i] = A[i + 1] * 0.6;
          A[i + 1] = -x * 0.6;
        }
        pts[5][0] = A;
      }
      for (const d of pts) {
        const p = new Float32Array(Array.isArray(d[0]) ? d[0] : Object.values(d[0]));
        const c = new Float32Array(Array.isArray(d[1]) ? d[1] : Object.values(d[1]));
        // guard: if colors missing/mismatched, fill white
        const col = (c.length === p.length) ? c : new Float32Array(p.length).fill(1);
        frames.push([p, col]);
      }
    }
    const single = await safeLoadGZJSON('./vaeora.json.gz');
    if (single && Array.isArray(single) && single.length === 2 &&
        Array.isArray(single[0]) && Array.isArray(single[1]) &&
        single[0].length === single[1].length && (single[0].length % 3 === 0)) {
      const p = new Float32Array(single[0]);
      const c = new Float32Array(single[1]);
      frames.push([p, c]); // <- APPEND
    }

    if (!frames.length) {
      throw new Error('No frames found.');
    }

    /* 3) Global centering across ALL frames (keeps everything aligned) */
    let minX = Infinity,
        maxX = -Infinity,
        minY = Infinity,
        maxY = -Infinity;
    for (const [p] of frames) {
      for (let i = 0; i < p.length; i += 3) {
        const x = p[i],
            y = p[i + 1];
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
    const cx = (minX + maxX) / 2,
        cy = (minY + maxY) / 2;

    const centered = frames.map(([p, c]) => {
      const out = new Float32Array(p.length);
      for (let i = 0; i < p.length; i += 3) {
        out[i] = p[i] - cx;
        out[i + 1] = p[i + 1] - cy;
        out[i + 2] = p[i + 2] || 0;
      }
      return [out, c];
    });

    /* 4) Links (gracefully handle missing file) */
    const linksByType = (await safeLoadGZJSON('./links.json.gz')) || {
      getLinks: [],
      logicLinks: [],
      hierarchyRelation: []
    };

    //console.log('Loaded data:', { frames: centered.length, linksByType });
    return { frames: centered, linksByType };
  }
  /* ================= Inline worker (no-transfer → no detach) ================= */
  const workerCode = `

  onmessage = (e)=>{
    let [nodesFrom, nodesTo, edgesFrom, edgesTo, relations, seed, params] = e.data;
    const { time, amp, freq, scale, gain, floorF, snap, dt } = params;

function easeInOutExpo(t){
  if (t <= 0) return 0;
  if (t >= 1) return 1;
  return t < 0.5 ? Math.pow(2, 20*t - 10)/2 : 1 - Math.pow(2, -20*t + 10)/2;
}

    const N = nodesTo.length/3;
for (let i=0;i<N;i++){
  const i3 = i*3;
  const dx0 = nodesTo[i3]-nodesFrom[i3];
  const dy0 = nodesTo[i3+1]-nodesFrom[i3+1];
  const dz0 = nodesTo[i3+2]-nodesFrom[i3+2];
  const dist0 = Math.sqrt(dx0*dx0 + dy0*dy0 + dz0*dz0);

  if (dist0 < snap){
    nodesFrom[i3]=nodesTo[i3]; nodesFrom[i3+1]=nodesTo[i3+1]; nodesFrom[i3+2]=nodesTo[i3+2];
  } else {
    const x = Math.min(1, dist0 / (scale || 1));    // 0..1
    // Gain + Floor + FPS-Normierung:
    let f = (gain || 0.08) * easeInOutExpo(x) * ((dt || 1/60) * 60);
    if (floorF) f = Math.max(f, floorF);            // z.B. 0.004
    // LERP
    nodesFrom[i3]   += dx0 * f;
    nodesFrom[i3+1] += dy0 * f;
    nodesFrom[i3+2] += dz0 * f;
  }

      // Wobble nur während Bewegung, distanz-gewichtet
      if (dist0 > 1e-4 && amp > 0 && freq > 0){
        const inv = 1 / dist0;
        const ux = dx0 * inv, uy = dy0 * inv, uz = dz0 * inv;
        const ax = Math.abs(ux) < 0.9 ? 1 : 0;
        const ay = Math.abs(ux) < 0.9 ? 0 : 1;
        const az = 0;
        let px = uy*az - uz*ay;
        let py = uz*ax - ux*az;
        let pz = ux*ay - uy*ax;
        const pl = Math.hypot(px,py,pz) || 1e-6;
        px /= pl; py /= pl; pz /= pl;

        const falloff = Math.min(1, Math.max(0, dist0 / (scale || 1)));
        const wob = amp * falloff * Math.sin(time * freq + seed[i]);

        nodesFrom[i3]   += px * wob;
        nodesFrom[i3+1] += py * wob;
        nodesFrom[i3+2] += pz * wob;
      }
    }

    // Edges aktualisieren
    for (let i=0;i<relations.length;i++){
      const v3=i*3, f3=relations[i].from*3, t3=relations[i].to*3;
      edgesFrom[v3]   = nodesFrom[f3];
      edgesFrom[v3+1] = nodesFrom[f3+1];
      edgesFrom[v3+2] = nodesFrom[f3+2];
      edgesTo[v3]     = nodesFrom[t3];
      edgesTo[v3+1]   = nodesFrom[t3+1];
      edgesTo[v3+2]   = nodesFrom[t3+2];
    }

    postMessage([nodesFrom, edgesFrom, edgesTo]);
  };
`;
  function makeWorker() {
    try { const blob = new Blob([workerCode], { type: 'text/javascript' }); const url = URL.createObjectURL(blob); return new Worker(url); } catch { return null; }
  }

  /* ================= Nodes ================= */
  function NodeCloud({ state }) {
    const { camera } = useThree();
    const root = React.useRef();
    const geo = React.useRef();
    const mat = React.useRef();
    const base = React.useMemo(() => new THREE.CircleGeometry(2, 30), []);

    React.useEffect(() => {
      const g = new THREE.InstancedBufferGeometry();
      g.index = base.index;
      g.attributes.position = base.attributes.position;
      g.attributes.normal = base.attributes.normal || undefined;
      g.attributes.uv = base.attributes.uv || undefined;
      geo.current = g;
      const m = new THREE.ShaderMaterial(nodeShader);
      mat.current = m;
      const mesh = new THREE.Mesh(g, m);
      mesh.matrixWorldNeedsUpdate = false
      mesh.matrixAutoUpdate = false
      mesh.frustumCulled = false;
      root.current.add(mesh);
      return () => {
        g.dispose();
        m.dispose();
        root.current.remove(mesh);
      };
    }, [base]);

    React.useEffect(() => {
      if (!state.nodesFrom) return;
      const count = state.nodesFrom.length / 3;
      const g = geo.current;
      g.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(new Float32Array(count * 3), 3));
      g.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(new Float32Array(count * 3), 3));
      g.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(new Float32Array(count), 1));
      g.setAttribute('instanceOpacity', new THREE.InstancedBufferAttribute(new Float32Array(count), 1));
      g.getAttribute('instanceColor').set(state.colFrom);
      const sWorld = pxToWorld(NODE_PX, state.camZ, camera.fov, state.viewportH);
      const sca = g.getAttribute('instanceScale'),
          opa = g.getAttribute('instanceOpacity');
      for (let i = 0; i < sca.count; i++) {
        sca.array[i] = sWorld;
        opa.array[i] = 1.0;
      }
      sca.needsUpdate = opa.needsUpdate = true;
      g.getAttribute('instanceColor').needsUpdate = true;
    }, [state.nodesFrom]);

    useFrame(() => {
      if (!geo.current || !mat.current) return;
      mat.current.uniforms.paillette.value += 0.03;

      if (state.nodesFrom) {
        const posA = geo.current.getAttribute('instancePosition');
        if (posA && posA.array.length === state.nodesFrom.length) {
          posA.array.set(state.nodesFrom);
          posA.needsUpdate = true;
        }
      }
      if (state.colFrom && state.colTo) {
        const a = 0.18;
        for (let i = 0; i < state.colTo.length; i++) state.colFrom[i] += (state.colTo[i] - state.colFrom[i]) * a;
        const colA = geo.current.getAttribute('instanceColor');
        if (colA && colA.array.length === state.colFrom.length) {
          colA.array.set(state.colFrom);
          colA.needsUpdate = true;
        }
      }
      if (state.needsScaleUpdate) {
        const sca = geo.current.getAttribute('instanceScale');
        if (sca) {
          const sWorld = pxToWorld(NODE_PX, state.camZ, state.fov, state.viewportH);
          for (let i = 0; i < sca.count; i++) sca.array[i] = sWorld;
          sca.needsUpdate = true;
          state.needsScaleUpdate = false;
        }
      }
    });

    return React.createElement('group', { ref: root });
  }

  /* ================= Edges ================= */
  function Edges({ state }) {
    const root = React.useRef();
    const geo = React.useRef();
    const mat = React.useRef();
    const quad = React.useMemo(() => {
      const g = new THREE.BufferGeometry();
      const a = new Float32Array([-1, 0, 0, 1, 0, 0, -1, 1, 0, -1, 1, 0, 1, 0, 0, 1, 1, 0]);
      g.setAttribute('position', new THREE.BufferAttribute(a, 3));
      return g;
    }, []);

    React.useEffect(() => {
      const g = new THREE.InstancedBufferGeometry();
      g.index = null;
      g.attributes.position = quad.attributes.position;
      geo.current = g;
      const m = new THREE.ShaderMaterial(edgeShader);
      // Optional: additive Blending lässt Linien „glühen“
      //m.blending = THREE.AdditiveBlending;
      m.transparent = true;
      m.depthTest = false;
      m.depthWrite = false;
      m.uniforms.width.value = edgeClipFromPx(EDGE_PX_EMPH);
      mat.current = m;
      const mesh = new THREE.Mesh(g, m);
      mesh.matrixWorldNeedsUpdate = false
      mesh.matrixAutoUpdate = false
      mesh.frustumCulled = false;
      root.current.add(mesh);
      return () => {
        g.dispose();
        m.dispose();
        root.current.remove(mesh);
      };
    }, [quad]);

    React.useEffect(() => {
      if (!state.edgePairs) return;
      const n = state.edgePairs.length,
          g = geo.current;
      g.setAttribute('instanceFrom', new THREE.InstancedBufferAttribute(new Float32Array(n * 3), 3));
      g.setAttribute('instanceTo', new THREE.InstancedBufferAttribute(new Float32Array(n * 3), 3));
      if (mat.current) {
        mat.current.uniforms.resolution.value.set(state.viewportW, state.viewportH);
        mat.current.uniforms.opacity.value = state.edgeOpacity;
        mat.current.uniforms.width.value = edgeClipFromPx(state.edgeWidthPx);
      }
    }, [state.edgePairs, state.viewportW, state.viewportH, state.edgeOpacity, state.edgeWidthPx]);

    useFrame(() => {
      if (!geo.current || !state.edgesFrom || !state.edgesTo) return;
      const fromA = geo.current.getAttribute('instanceFrom');
      const toA = geo.current.getAttribute('instanceTo');
      if (fromA && toA && fromA.array.length === state.edgesFrom.length && toA.array.length === state.edgesTo.length) {
        fromA.array.set(state.edgesFrom);
        toA.array.set(state.edgesTo);
        fromA.needsUpdate = true;
        toA.needsUpdate = true;
      }
      if (mat.current) {
        // Live-Spiegelung: Breite & Opacity pro Frame aus state
        const wantW = edgeClipFromPx(state.edgeWidthPx);
        if (mat.current.uniforms.width.value !== wantW) mat.current.uniforms.width.value = wantW;
        if (mat.current.uniforms.opacity.value !== state.edgeOpacity) mat.current.uniforms.opacity.value = state.edgeOpacity;
      }
    });

    return React.createElement('group', { ref: root });
  }

  /* ================= Camera sync ================= */
  function CameraSync({ state }) {
    const { camera, gl } = useThree();
    React.useEffect(() => {
      camera.fov = state.fov;
      camera.near = CAMERA_NEAR;
      camera.far = CAMERA_FAR;
      camera.updateProjectionMatrix();
    }, [camera, state.fov]);

    React.useEffect(() => {
      gl.setPixelRatio(state.dpr);
      gl.setSize(state.viewportW, state.viewportH, false);
      gl.outputColorSpace = THREE.SRGBColorSpace;
      gl.toneMapping = THREE.ACESFilmicToneMapping;
      gl.toneMappingExposure = 1.2;
    }, [gl, state.viewportW, state.viewportH, state.dpr]);

    useFrame(() => {
      if (!state.cameraPos) state.cameraPos = [0, 0, 0];
      state.cameraPos[0] = camera.position.x;
      state.cameraPos[1] = camera.position.y;
      state.cameraPos[2] = camera.position.z;
    });
    return null;
  }

  /* ================= App / Scene ================= */
  function App() {
    const [data, setData] = React.useState(null);
    React.useEffect(() => {
      (async () => {
        try {
          setData(await loadFramesAndLinks());
        } catch (e) {
          console.log(e.message);
          console.error('Failed to load data.');
        }
      })();
    }, []);
    return data ? React.createElement(Scene, { data }) : null;
  }

  function Scene({ data }) {
    const [dims, setDims] = React.useState({ w: innerWidth, h: innerHeight, dpr: Math.min(devicePixelRatio || 1, 2) });

    React.useEffect(() => {
      const onR = () => setDims({ w: innerWidth, h: innerHeight, dpr: Math.min(devicePixelRatio || 1, 2) });
      addEventListener('resize', onR, { passive: true });
      return () => removeEventListener('resize', onR);
    }, []);

    const [uiStep, setUiStep] = React.useState(0);

    const [bg, setBg] = React.useState(BACKG[0]);

    React.useEffect(() => setBG(bg), [bg]);

    const [settings, setSettings] = React.useState({
      layout: Object.keys(layouts)[0],
      colorScale: 'users',
      edges: { display: true, opacity: 0.05, width: EDGE_PX_EMPH },
      nodes: { display: true, opacity: 1, width: 1 },
      axises: {
        axis1: {
          value: 'startDay',
          bounds: {
            values: [0, 360]
          }
        },
        axis2: {
          value: 'startTime',
          bounds: {
            values: [100, 500]
          }
        },
        axis3: {
          value: 'collaborationNumber',
          bounds: {
            values: [-300, 300]
          }
        }
      }
    });

    const state = React.useRef({
      viewportW: dims.w,
      viewportH: dims.h,

      dpr: dims.dpr,
      fov: FOV,
      camZ: dims.h * 0.5 / ratio,

      needsScaleUpdate: true,
      nodesFrom: null,
      nodesTo: null,

      colFrom: null,
      colTo: null,

      edgesFrom: null,
      edgesTo: null,
      edgePairs: [],
      edgeOpacity: 0.0,
      edgeWidthPx: EDGE_PX_EMPH,

      wobbleAmp   : 1.1,
      wobbleFreq  : 4,
      wobbleScale : 1,   // wird dynamisch gesetzt

      tailStart: 0.80,     // 80% schnell, 20% Tail
      fFast     : 0.03,    // konstantes Tempo in den ersten 80% (pro 60 FPS)
      tailGain  : 0.01,    // Stärke im Tail (pro 60 FPS)
      floorF    : 0.01,   // Mindestschritt

      snapDist : 1e-5,   // unterhalb: direkt aufs Ziel setzen

      workerTicks: 0
    }).current;

    const setEdgeOpacity = (o) => { state.edgeOpacity = o; };
    const setEdgeWidthPx = (px) => { state.edgeWidthPx = px; };
    const setBackground = (c) => setBg(c);

    // changed
    const setStep = () => setUiStep(prev => (prev + 1) % MESSAGES.length);

    React.useEffect(() => {
      state.viewportW = dims.w;
      state.viewportH = dims.h;
      state.dpr = dims.dpr;
      state.fov = FOV;
      state.needsScaleUpdate = true;
    }, [dims]);


    // ================= Init (in Scene.useEffect nach loadFramesAndLinks) =================
    React.useEffect(() => {
      const [p0, c0] = data.frames[0];
      const N = p0.length / 3;

      // Speicher anlegen, aber NICHT chaotisch füllen
      state.nodesFrom = new Float32Array(p0.length);           // bleibt 0 bis bumpFrame()
      state.nodesTo   = new Float32Array(p0.length);           // Ziel wird in bumpFrame gesetzt
      state.colFrom   = new Float32Array(c0.length);
      state.colTo     = new Float32Array(c0.length);
      state.initDist  = new Float32Array(N);

      // Seeds für optionales Wobble
      state.seed = new Float32Array(N);
      for (let i=0;i<N;i++) state.seed[i] = Math.random() * 1000;

      // Defaults für Lerp/Timing
      state.tailStart = state.tailStart ?? 0.8;   // 80% schnell
      state.fFast     = state.fFast     ?? 0.16;  // pro 60 FPS
      state.tailGain  = state.tailGain  ?? 0.14;  // pro 60 FPS
      state.floorF    = state.floorF    ?? 0.003;
      state.snapDist  = state.snapDist  ?? 0;

      // Wobble-Defaults (kann 0 bleiben)
      state.wobbleAmp  = state.wobbleAmp  ?? 0;
      state.wobbleFreq = state.wobbleFreq ?? 0;

      // Edges vorbereiten
      setLayoutEdges(settings.layout);

      // erster Frame wird via bumpFrame gesetzt
      setBG(BACKG[0]);

      // Render-Loop starten (ohne Worker)
      requestAnimationFrame(tickFallback);
    }, []);


    function setLayoutEdges(layoutKey) {
      const key = linksKeyForLayout(layoutKey);
      const raw = data.linksByType[key] || [];
      const pairs = dedupeLinks(raw);

      state.edgePairs = pairs;
      state.edgesFrom = new Float32Array(pairs.length * 3);
      state.edgesTo = new Float32Array(pairs.length * 3);
    }

    React.useEffect(() => { setLayoutEdges(settings.layout); }, [settings.layout]);

    const frameRef = React.useRef(-1);
    window.frameRef = frameRef;

    window.setEdgeOpacity = setEdgeOpacity;
    window.setEdgeWidthPx = setEdgeWidthPx;
    window.setSettings = setSettings;
    window.setBackground = setBackground;
    window.setStep = setStep;
    window.state = state;
    window.data = data;

// ================= bumpFrame (komplett) =================
    const bumpFrame = React.useCallback(() => {
      // Erstaufruf: Offscreen-Spawn + erstes Ziel setzen
      if (frameRef.current === -1) {
        frameRef.current = 0;

        const [p0, c0] = data.frames[0];
        const N = p0.length / 3;

        // --- 1) Offscreen-Spawn basierend auf Kamera/Viewport ---
        const aspect = state.viewportW / state.viewportH;
        const viewH  = 2 * Math.tan((state.fov * Math.PI / 180) * 0.5) * state.camZ;
        const viewW  = viewH * aspect;
        const diagR  = Math.hypot(viewW * 0.5, viewH * 0.5);
        const spawnR = diagR * 1.25; // 25% außerhalb des Bildes

        for (let i = 0; i < N; i++) {
          const a = Math.random() * Math.PI * 2;     // Ring
          state.nodesFrom[i*3+0] = Math.cos(a) * spawnR;
          state.nodesFrom[i*3+1] = Math.sin(a) * spawnR;
          state.nodesFrom[i*3+2] = 0;                // oder leichte Z-Varianz
        }

        // --- 2) Wobble temporär aus, damit sauber einfliegen ---
        state.initialFlight = true;
        state._wobbleBackup = { amp: state.wobbleAmp, freq: state.wobbleFreq };
        state.wobbleAmp = 0; state.wobbleFreq = 0;

        // --- 3) Ziel + Farben auf erstes Frame ---
        state.nodesTo.set(p0);
        state.colTo.set(c0);
        // colFrom initial gleich colTo (keine Farb-Interps beim ersten Setzen)
        state.colFrom.set(c0);

        // --- 4) initDist + wobbleScale berechnen ---
        const dists = new Array(N);
        for (let i=0;i<N;i++){
          const i3=i*3;
          const d = Math.hypot(
              state.nodesTo[i3]-state.nodesFrom[i3],
              state.nodesTo[i3+1]-state.nodesFrom[i3+1],
              state.nodesTo[i3+2]-state.nodesFrom[i3+2]
          );
          state.initDist[i] = d;
          dists[i] = d;
        }
        dists.sort((a,b)=>a-b);
        state.wobbleScale = Math.max(1e-6, dists[Math.floor(0.9*(N-1))] || 1);

        return; // fertig für den ersten Flug
      }

      // Folgeaufrufe: normales Weiterschalten
      frameRef.current = (frameRef.current + 1) % data.frames.length;
      const [p, c] = data.frames[frameRef.current];

      state.nodesTo.set(p);
      state.colTo.set(c);
      if (!state.colFrom || state.colFrom.length !== c.length) {
        state.colFrom = new Float32Array(c);
      }

      // initDist + wobbleScale für neue Transition
      const N = p.length / 3;
      const dists = new Array(N);
      for (let i=0;i<N;i++){
        const i3=i*3;
        const d = Math.hypot(
            state.nodesTo[i3]-state.nodesFrom[i3],
            state.nodesTo[i3+1]-state.nodesFrom[i3+1],
            state.nodesTo[i3+2]-state.nodesFrom[i3+2]
        );
        state.initDist[i] = d;
        dists[i] = d;
      }
      dists.sort((a,b)=>a-b);
      state.wobbleScale = Math.max(1e-6, dists[Math.floor(0.9*(N-1))] || 1);
    }, [data.frames, state]);

    /* ---- LERP loop (worker or main) ---- */
    let worker;
    let lerping=false;
    const useWorker = false;
    function startLerpLoop() {
      worker = useWorker ? makeWorker() : null;
      if (worker) {
        worker.onmessage = (e)=>{
          const [nodesFromArr, edgesFromArr, edgesToArr] = e.data;
          state.nodesFrom = nodesFromArr;
          state.edgesFrom = edgesFromArr;
          state.edgesTo   = edgesToArr;
          state.workerTicks++;
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      } else {
        requestAnimationFrame(tickFallback);
      }
    }

    let lastT = performance.now();

    function tick(){
      const now = performance.now();
      const dt  = Math.max(1/120, (now - lastT) / 1000); // s
      lastT = now;

      worker.postMessage([
        state.nodesFrom, state.nodesTo, state.edgesFrom, state.edgesTo, state.edgePairs,
        state.seed,
        {
          time: now*0.001,
          amp: state.wobbleAmp,
          freq: state.wobbleFreq,
          scale: state.wobbleScale,
          gain: 0.10,          // Startempfehlung: 0.08–0.18
          floorF: 0.025,       // Minimaler Schritt, verhindert „stehen bleiben“
          snap: 1e-4,
          dt
        }
      ]);
    }

    function easeOutExpo(t){ return t<=0?0 : t>=1?1 : 1 - Math.pow(2, -10*t); }

    function easeInOutExpo(t){
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      return t < 0.5
          ? Math.pow(2, 20 * t - 10) / 2
          : 1 - Math.pow(2, -20 * t + 10) / 2;
    }

    function tickFallback(){
      const now = performance.now();
      const dt  = Math.max(1/120, (now - lastT) / 1000); // Sekunden
      lastT = now;

      const nf = state.nodesFrom, nt = state.nodesTo, rel = state.edgePairs;
      if (!nf || !nt || !rel) { requestAnimationFrame(tickFallback); return; }

      const N = nt.length / 3;
      const dt60 = dt * 60;
      const tailStart = state.tailStart;
      const fFast  = Math.max(state.floorF, state.fFast * dt60);
      const gain   = state.tailGain * dt60;
      const floorF = state.floorF;
      const snap   = state.snapDist || 0;

      // Wobble
      const amp  = state.wobbleAmp  || 0;
      const freq = state.wobbleFreq || 0;
      const scale = state.wobbleScale > 0 ? state.wobbleScale : 1;
      const seed = state.seed || (state.seed = new Float32Array(N));

      // Positions-Update
      for (let i=0;i<N;i++){
        const i3 = i*3;

        const dx0 = nt[i3]   - nf[i3];
        const dy0 = nt[i3+1] - nf[i3+1];
        const dz0 = nt[i3+2] - nf[i3+2];
        const dist0 = Math.hypot(dx0, dy0, dz0);

        if (dist0 < snap){
          nf[i3]=nt[i3]; nf[i3+1]=nt[i3+1]; nf[i3+2]=nt[i3+2];
        } else {
          // exakter Fortschritt je Node relativ zur initialen Distanz
          const id = Math.max(1e-6, state.initDist ? state.initDist[i] : scale);
          const progress = 1 - dist0 / id; // 0..1

          let f;
          if (progress < tailStart){
            f = fFast; // 0..80%: konstantes schnelles LERP
          } else {
            const tTail = (progress - tailStart) / (1 - tailStart); // 0..1
            f = Math.max(floorF, gain * easeOutExpo(tTail));        // 80..100%: Expo-Bremse
          }

          nf[i3]   += dx0 * f;
          nf[i3+1] += dy0 * f;
          nf[i3+2] += dz0 * f;
        }

        // Optionales perpendikuläres Wobble nur während Bewegung
        if (amp > 0 && freq > 0){
          const dx = nt[i3]-nf[i3], dy = nt[i3+1]-nf[i3+1], dz = nt[i3+2]-nf[i3+2];
          const dist = Math.hypot(dx,dy,dz);
          if (dist > 1e-4){
            const inv = 1/dist, ux=dx*inv, uy=dy*inv, uz=dz*inv;
            const ax = Math.abs(ux) < 0.9 ? 1 : 0, ay = Math.abs(ux) < 0.9 ? 0 : 1, az = 0;
            let px = uy*az - uz*ay, py = uz*ax - ux*az, pz = ux*ay - uy*ax;
            const pl = Math.hypot(px,py,pz) || 1e-6; px/=pl; py/=pl; pz/=pl;
            const falloff = Math.min(1, Math.max(0, dist / scale));
            const wob = amp * falloff * Math.sin(now*0.001 * freq + seed[i]);
            nf[i3] += px*wob; nf[i3+1] += py*wob; nf[i3+2] += pz*wob;
          }
        }
      }

      // Edges updaten
      if (!state.edgesFrom || state.edgesFrom.length !== rel.length*3)
        state.edgesFrom = new Float32Array(rel.length*3);
      if (!state.edgesTo || state.edgesTo.length !== rel.length*3)
        state.edgesTo = new Float32Array(rel.length*3);

      for (let i=0;i<rel.length;i++){
        const v3=i*3, f3=rel[i].from*3, t3=rel[i].to*3;
        state.edgesFrom[v3]   = nf[f3];
        state.edgesFrom[v3+1] = nf[f3+1];
        state.edgesFrom[v3+2] = nf[f3+2];
        state.edgesTo[v3]     = nf[t3];
        state.edgesTo[v3+1]   = nf[t3+1];
        state.edgesTo[v3+2]   = nf[t3+2];
      }

      // ================= Re-Enable Wobble während des ersten Flugs (am Ende von tickFallback) =================
      if (state.initialFlight) {
        // groben Fortschritt schätzen
        const nf = state.nodesFrom, nt = state.nodesTo;
        const N = nt.length/3;
        let acc=0, cnt=0;
        for (let i=0;i<N;i+=256){
          const i3=i*3;
          const d0 = state.initDist[i] || 1;
          const d  = Math.hypot(nt[i3]-nf[i3], nt[i3+1]-nf[i3+1], nt[i3+2]-nf[i3+2]);
          acc += 1 - d/Math.max(1e-6, d0); cnt++;
        }
        const avg = acc / Math.max(1, cnt);
        if (avg > 0.2) { // nach ~20% Weg Wobble wieder an
          if (state._wobbleBackup) {
            state.wobbleAmp  = state._wobbleBackup.amp ?? state.wobbleAmp;
            state.wobbleFreq = state._wobbleBackup.freq ?? state.wobbleFreq;
          }
          state.initialFlight = false;
        }
      }

      requestAnimationFrame(tickFallback);
    }
    React.useEffect(() => () => { if (worker) worker.terminate(); }, []);

    window.setLerpTail = (min,max,snap) => {state.lerpMin=min; state.lerpMax=max; state.snapDist=snap};
    window.setWobble = (amp,freq) => {state.wobbleAmp=amp; state.wobbleFreq=freq};

    return React.createElement(
        'div', {
          className: 'R3FHeader',
          style: {
            width: '100%',
            height: '100vh',
            display: 'flex',
            background: '#030519',
            transition: 'background 1s',
            position: 'relative',
          }
        },
        [
          React.createElement(Canvas, {
            key: 'canvas',
            dpr: [1, dims.dpr],
            camera: { fov: FOV, near: CAMERA_NEAR, far: CAMERA_FAR, position: [0, 0, state.camZ] },
            onCreated: ({ gl, camera }) => {
              gl.setPixelRatio(dims.dpr);
              gl.setSize(dims.w, dims.h, false);
              gl.outputColorSpace = THREE.SRGBColorSpace;
              gl.toneMapping = THREE.ACESFilmicToneMapping;
              gl.toneMappingExposure = 1.2;
              camera.fov = FOV;
              camera.near = CAMERA_NEAR;
              camera.far = CAMERA_FAR;
              camera.position.set(0, 0, state.camZ);
              camera.updateProjectionMatrix();
            },
            style: { position: 'absolute', inset: 0, zIndex: 0, height: window.innerHeight, opacity: 0.8 },
          }, [
            React.createElement(CameraSync, { key: 'cam', state }),
            React.createElement(NodeCloud, { key: 'nodes', state }),
            React.createElement(Edges, { key: 'edges', state }),
            React.createElement(Animation, {
              key: 'anim',
              settings,
              setSettings,
              setEdgeOpacity,
              setBackground,
              setStep,
              setEdgeWidthPx,
              bumpFrame
            }),
          ]),
          React.createElement(Title, { key: 'title', current: uiStep }),
        ]
    );
  }

  const RAD2DEG = 180 / Math.PI;
  const DEG2RAD = Math.PI / 180;

  function moveCamera(lng, lat, radius = window.innerHeight * 0.5) {
    const phi = Math.PI / 2 - lat; // polar/elevation
    const theta = lng + Math.PI; // azimuth (Dataset-Ausrichtung)
    return [-(radius * Math.sin(phi) * Math.sin(theta)),
      (radius * Math.cos(phi)),
      -(radius * Math.sin(phi) * Math.cos(theta))]
  }

  function Animation({ settings, setSettings, setEdgeOpacity, setBackground, setStep, setEdgeWidthPx, bumpFrame }) {
    const { camera } = useThree();

    React.useEffect(() => {
      function deplaceCAmera(lat, lng, radius) {
        camera.position.set(...moveCamera(lat, lng, radius));
        camera.lookAt(0, 0, 0);
      }

      const settingsClone = { ...settings };
      const animations = [];
      let running = true;

      async function run() {
        let currentSettings = settingsClone;
        const width = window.innerWidth,
            height = window.innerHeight;

        let offset = 0;



        const calcOffset = s => offset = offset + s


                setTimeout(()=>{
                  if(window.frameRef.current < 0) {
                    bumpFrame();
                    setTimeout(setStep, 1000)
                  }
                }, 1000);

                // zoom-like effekt direkt nach dem intro schwenk
                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 1500);
                }, calcOffset(7000));

                // formt collaboration "tube"
                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 3000);
                }, calcOffset(3000));

                // connections mit edges collapse zu circle
                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 1000);
                }, calcOffset(5000));

                // circle extrusion mit edges
                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 2400);
                }, calcOffset(2800));

                // circle transform to grid
                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 3000);
                }, calcOffset(3000));

                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 1000);
                }, calcOffset(6000));

                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 1500);
                }, calcOffset(5000));

                setTimeout(() => {
                  bumpFrame();
                  setTimeout(setStep, 500);
                }, calcOffset(8000));


        const state = {
          cameraLat: Math.PI,
          cameraLng: 0,
          cameraRadius: height * 0.5,
          edgeOpacity: 0
        }

        const activeSteps = { 1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true };

        /* ------------------------- STEP 1 ---------------------------------
           Easing: easeInOutExpo, Dauer 4000ms.
        ------------------------------------------------------------------ */
        if (running && activeSteps[1]) {

          const a = anime({
            targets: state,
            ...{
              cameraLat: Math.PI * 2,
              cameraRadius: state.cameraRadius / ratio
            },
            delay: 0,
            duration: 4000,
            easing: 'easeInOutExpo',
            changeBegin: function () {
              if (!running) return;
              currentSettings = { ...currentSettings, ...{ edges: { ...currentSettings.edges, display: false } },
                layout: Object.keys(layouts)[0],
                colorScale: 'users',
                axises: {
                  axis1: { value: 'startDay', bounds: { values: [0, 360] } },
                  axis2: { value: 'startTime', bounds: { values: [100, 600] } },
                  axis3: { value: 'collaborationNumber', bounds: { values: [-300, 300] } },
                },
              };
              setBackground(BACKG[0]);
              setEdgeOpacity(0.0);
              setSettings(currentSettings);
            },
            update: function (v) {
              if (running && v.changeBegan) {
                deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius);
              }
            },
          }).finished;
          animations.push(a);
          await a;
        }

        /* ------------------------- STEP 2 ---------------------------------
           - .add mit Dummy-Target, um "changeBegin" (einmalig) zu bekommen → setSettings.
           - Danach längerer Kameraschwenk (10s) mit easing 'easeInOutExpo'.
        ------------------------------------------------------------------ */
        if (running && activeSteps[2]) {
          animations.push(anime.timeline({ easing: 'easeInOutExpo' }).add({
            targets: { i: 0 },
            ...{ i: 1 },
            delay: 2000,
            duration: 100,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                axises: {
                  ...currentSettings.axises,
                  axis3: { value: 'users', bounds: { values: [(-window.innerWidth * 0.3) / ratio, (window.innerWidth * 0.3) / ratio] } }
                }
              };
              setSettings(currentSettings);

            },
          }));

          animations.push(anime.timeline({
                delay: 1000,
                duration: 12000
              }).add({
                easing: 'easeInOutExpo',
                targets: state,
                ...{
                  cameraLat: Math.PI * 2.55,
                  cameraRadius: (height * 0.9) / ratio
                },
                duration: 10000,
                changeBegin: function () {
                  if (!running) return;
                  console.debug(".")

                },
                update: function (v) { if (running && v.changeBegan) deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius);
                },
              })
          );
        }

        /* ------------------------- STEP 3 ---------------------------------
           "Connections emerge": Edges EIN (sichtbar) + BREITER.
           Zwei Segmente:
           1) Softes Einblenden der Edge-Opacity (0 → 0.5) über 4s (linear).
              → Im begin() schalten wir auch die Breite hoch (EDGE_PX_EMPH).
           2) Achsenwechsel auf 'projects' (axis2), 'users' (axis3), Kanten bleiben an.
        ------------------------------------------------------------------ */
        if (running && activeSteps[3]) {
          const a = anime.timeline({ easing: 'easeInOutExpo' })
          .add({
            targets: { opacity: 0 },
            opacity: 0.15,
            delay: 7000,
            easing: 'linear',
            duration: 4000,
            update: function (v) { if (running && v.changeBegan) setEdgeOpacity(v.animatables[0].target.opacity); },
          }).add({
            targets: { i: 0 },
            ...{ i: 1 },
            duration: 4000,
            delay: 6000,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                /*edges: {
                  ...currentSettings.edges,
                  display: true
                },*/
                axises: {
                  ...currentSettings.axises,
                  axis2: { value: 'projects', bounds: { values: [100, 700] } },
                  axis3: { value: 'users', bounds: { values: [(-width * 0.3) / ratio, (width * 0.3) / ratio] } },
                },
              };
              setEdgeWidthPx(EDGE_PX_EMPH*2);
              setSettings(currentSettings);
            },
          }, 10).finished;
          animations.push(a);
          await a;
        }

        /* ------------------------- STEP 4 ---------------------------------
           Farbwechsel (BACKGROUND 1), Skala 'collaborationNumber', weitere Bounds.
           Kanten wieder AUS (Opacity 0)
           Dazu kurzer Kameraschritt.
        ------------------------------------------------------------------ */
        if (running && activeSteps[4]) {
          const a = anime.timeline({ easing: 'easeInOutExpo' })
          .add({
            targets: state,
            ...{
              cameraLat: Math.PI * 2
            },
            duration: 2000,
            update: function (v) { if (running && v.changeBegan) deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius); },
          })
          .add({
            targets: { i: 0 },
            ...{ i: 1 },
            duration: 100,
            changeBegin: function () {
              if (!running) return;
              setEdgeWidthPx(EDGE_PX_EMPH*4)
              setBackground(BACKG[1]);
              currentSettings = {
                ...currentSettings,
                colorScale: 'collaborationNumber',
                edges: {
                  ...currentSettings.edges,
                  opacity: 0.05,
                  width: 1,
                  display: true
                },
                axises: {
                  ...currentSettings.axises,
                  axis2: { value: 'projectTasks', bounds: { values: [100, 500] } },
                  axis3: { value: 'users', bounds: { values: [-1, 1] } },
                },
              };
              setEdgeOpacity(0.05)
              setSettings(currentSettings);
            },
          }, 200).add({
            targets: { i: 0 },
            ...{ i: 1 },
            duration: 100,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                edges: {
                  ...currentSettings.edges,
                  opacity: 0.05,
                  width: 1,
                  display: true
                },
                axises: {
                  ...currentSettings.axises,
                  axis2: { value: 'projectTasks', bounds: { values: [100, 500] } },
                  axis3: {
                    value: 'collaborationNumber',
                    bounds: { values: [-1, 500] }
                  },
                },
              };
              // CIRCLE EXTRUSION SETTINGS
              setEdgeOpacity(0.05)
              setEdgeWidthPx(EDGE_PX_EMPH * 4);
              setSettings(currentSettings);
            },
          }, 1500).add({
            easing: 'easeInOutExpo',
            targets: state,
            ...{
              cameraLng: Math.PI * -0.25,
              cameraRadius: (height * 0.65) / ratio
            },
            duration: 5000,
            update: function (v) { if (running && v.changeBegan) deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius); },
          }, 1000).finished;
          animations.push(a);
          await a;
        }

        /* ------------------------- STEP 5 ---------------------------------
           Übergang ins Grid-Layout, Zoom/FOV-Gefühl, Kanten bleiben AUS.
           Drei Segmente (kurzer EaseInOut → linearer Drift → Layoutwechsel).
        ------------------------------------------------------------------ */
        if (running && activeSteps[5]) {
          const a = anime.timeline({})
          .add({
            targets: state,
            ...{
              cameraLng: 0,
              cameraRadius: (height * 0.71) / (isMobile ? yRatio : xRatio)
            },
            easing: 'easeInOutExpo',
            duration: 1000,
            update: function (v) { if (running && v.changeBegan) deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius); },
          })
          .add({
            targets: state,
            ...{
              cameraLat: state.cameraLat + Math.PI * 0.01,
              cameraRadius: (height * 0.62) / (isMobile ? yRatio : xRatio),
            },
            easing: 'linear',
            duration: 5000,
            update: function (v) { if (running && v.changeBegan) deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius); },
          }, 1000)
          .add({
            targets: { i: 0 },
            ...{ i: 1 },
            duration: 6000,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                layout: Object.keys(layouts)[1],
                colorScale: 'projects',
                edges: { ...currentSettings.edges, display: false },
                axises: {
                  axis1: { value: 'startDay', bounds: { values: [-width * 0.48, width * 0.48] } },
                  axis2: { value: 'projectTasks', bounds: { values: [-height * 0.45, height * 0.45] } },
                  axis3: { value: 'collaborationNumber', bounds: { values: [-2, 2] } },
                },
              };
              setTimeout(setEdgeOpacity, 1000, 0.0);
              setBackground(BACKG[2]);
              setSettings(currentSettings);
            }
          }, 0).finished;
          animations.push(a);
          await a;
        }

        animations.push(anime({
          targets: state,
          ...{
            cameraLat: Math.PI * 2.6,
            cameraRadius: (height * 1.1) / ratio
          },
          easing: 'linear',
          duration: 19000,
          delay: 0,
          complete: () => {
            if (running) {
              //running = false;
              //animations.forEach(d=>anime.remove(d));
              bumpFrame();
              run();
            }
          },
          update: function (v) {
            if (running && v.changeBegan) {
              deplaceCAmera(state.cameraLat, state.cameraLng, state.cameraRadius);
            }
          },
        }));

        /* ------------------------- STEP 6 ---------------------------------
           „Logic binds…“: Layout coral, Edges wieder EIN + BREITER (Betonung).
           Ein Segment zum Ein-/Umschalten.
        ------------------------------------------------------------------ */
        if (activeSteps[6]) {
          const a = anime.timeline({ easing: 'easeInOutExpo' })
          .add({
            targets: { opacity: 0 },
            opacity: 0.05,
            duration: 3000,
            update: function (v) { if (running && v.changeBegan) setEdgeOpacity(v.animatables[0].target.opacity); },
          })
          .add({
            targets: { i: 0 },
            ...{ i: 1 },
            delay: 0,
            duration: 6000,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                layout: Object.keys(layouts)[3],
                edges: {
                  ...currentSettings.edges,
                  display: true,
                  opacity:0.1
                }
              };
              setEdgeWidthPx(EDGE_PX_EMPH*4);
              setSettings(currentSettings);
            },
          }, 200).finished;
          animations.push(a);
          await a;
        }

        /* ------------------------- STEP 7 ---------------------------------
           Neuordnung (forceLayout), Edges wieder AUS und zurück auf „dünn“.
        ------------------------------------------------------------------ */
        if (running && activeSteps[7]) {
          const a = anime.timeline({
            easing: 'easeInOutExpo',
            duration: 8000,
            delay: 3000
          })
          .add({
            targets: { i: 0 },
            ...{ i: 1 },
            delay: 1000,
            duration: 4000,
            changeBegin: function () {
              if (!running) return;
              currentSettings = {
                ...currentSettings,
                edges:{
                  ...currentSettings.edges,
                  display:false
                },
                layout: Object.keys(layouts)[2]
              };
              setEdgeWidthPx(EDGE_PX_EMPH);
              setEdgeOpacity(0.0);
              setSettings(currentSettings);
            },
          }, 200).finished;
          animations.push(a);
          await a;
        }
      }

      run();

      return () => {
        running = false;
        animations.forEach(
            d => anime.remove(d)
        );
      };
    }, []);

    return null;
  }



  /* ================= Boot ================= */
  if (!webglOK()) { alert('WebGL unavailable. Enable hardware acceleration.'); }
  createRoot(document.getElementById('root')).render(
      React.createElement(IntlProvider, { locale: 'en', messages: MESSAGES }, React.createElement(App)),
  );
</script>

<script type="module">
  import * as THREE from 'three';


  window.addEventListener('DOMContentLoaded', () => {
    removeLoader();

    const svgMarkup = `<svg xmlns="http://www.w3.org/2000/svg" class="vaeora-wordmark" viewBox="0 0 700 100" width="200px" preserveAspectRatio="xMidYMid meet">
<defs>
<linearGradient gradientUnits="userSpaceOnUse" x1="50" y1="0" x2="50" y2="100" id="gradient-1" spreadMethod="pad" gradientTransform="matrix(-0.358977, 0.93331, -0.730712, -0.499981, 67.042038, 53.336289)"><stop offset="0" style="stop-color: rgb(255, 255, 255);"/>
<stop offset="0.1" style="stop-color: rgb(255, 255, 255);"/>
<stop offset="0.11" style="stop-opacity: 0;"/>
<stop offset="0.17" style="stop-opacity: 0;"/>
<stop offset="0.63" style="stop-color: rgb(255, 255, 255);"/>
<stop offset="1" style="stop-color: rgb(255, 255, 255);"/>
</linearGradient>
</defs>
    <path d="M 50 74 L 80 0 L 100 0 L 60 100 L 40 100 L 50 74 L 50 74 Z M 0 0 L 20 0 L 50 74 L 40 100 L 0 0 Z"
        style="fill: url(&quot;#gradient-1&quot;);" id="v"/>
    <path
        d="M 201.58 100 L 191.4 71.43 L 148.43 71.43 L 138.19 100 L 120 100 L 156.73 0 L 183.28 0 L 220 100 L 201.58 100 Z M 153.72 56.56 L 186 56.56 L 169.88 11.35 L 153.72 56.56 Z"
        style="will-change: opacity, transform; fill: rgb(255, 255, 255);" id="a">
<animate attributeName="visibility" values="hidden;visible;hidden" dur="4s" fill="freeze" calcMode="discrete" keyTimes="0; 0.13948; 1"/>
<animate attributeName="opacity" values="0;0;1;1;0;0" dur="3.83s" fill="freeze" keyTimes="0; 0.158938; 0.25124; 0.77023; 0.84594; 1" calcMode="spline" keySplines="0.7 0 0.84 0; 0.7 0 0.84 0; 0.7 0 0.84 0; 0.7 0 0.84 0; 0.7 0 0.84 0"/>
<animateTransform type="translate" additive="sum" attributeName="transform" values="-250 0;0 0;0 0;-115 0;-150 0" dur="4s" fill="freeze" keyTimes="0; 0.31715; 0.725; 0.904705; 1" calcMode="spline" keySplines="0.87 0 0.13 1; 0.55 0 1 0.45; 0.09 0 0.34 0.58; 1 0 0.87 1" restart="whenNotActive"/>
</path>
    <path
        d="M 244 56.13 L 244 85.23 L 244 56.13 Z M 244 14.76 L 334 14.68 L 334 0 L 244 0 L 244 56.13 L 324.96 56.21 L 324.96 41.43 L 244 41.44 L 244 14.76 Z M 244 100 L 334 100 L 334 85.19 L 244 85.23 L 244 100 Z"
        style="will-change: opacity, transform; fill: rgb(255, 255, 255);" id="e">
<animate attributeName="visibility" values="hidden;visible;hidden" dur="4.14s" fill="freeze" calcMode="discrete" keyTimes="0; 0.1715; 1"/>
<animate attributeName="opacity" values="0;1;1;0;0" dur="3.36s" fill="freeze" keyTimes="0; 0.13665; 0.67262; 0.79965; 1" calcMode="spline" keySplines="0.7 0 0.84 0; 0.12 0 0.39 0; 0.7 0 0.84 0; 0.7 0 0.84 0" begin="0.69s"/>
<animateTransform type="translate" additive="sum" attributeName="transform" values="-200 0;0 0;0 0;-250 0;-200 0" dur="4.05s" fill="freeze" keyTimes="0; 0.40628; 0.72099; 0.89383; 1" calcMode="spline" keySplines="0.87 0 0.13 1; 0.55 0 1 0.45; 0.68 0 0.51 1; 0.55 0 1 0.45"/>
</path>
    <path
        d="M 404.98 100 C 394.75 100 385.91 98.11 378.42 94.31 C 370.93 90.5 365.14 84.87 361.1 77.37 C 357 69.88 355 60.76 355 50 C 355 39.23 357 30.12 361.13 22.62 C 365.21 15.14 371 9.5 378.49 5.71 C 385.98 1.89 394.81 0 404.98 0 C 415.18 0 424 1.91 431.57 5.74 C 439 9.55 444.85 15.2 448.92 22.7 C 452.98 30.19 455 39.28 455 50 C 455 60.71 452.95 69.83 448.85 77.3 C 444.75 84.8 438.94 90.44 431.47 94.27 C 423.98 98.11 415.13 100 404.98 100 Z M 404.98 84.85 C 414.75 84.85 422.31 81.99 427.67 76.28 C 433 70.59 435.69 61.94 435.69 50.4 C 435.69 38.51 432.99 29.64 427.6 23.85 C 422.21 18 414.67 15.15 404.98 15.15 C 395.29 15.15 387.74 18 382.35 23.69 C 376.95 29.38 374.27 38 374.27 49.6 C 374.27 61.59 376.93 70.48 382.29 76.22 C 387.63 81.97 395.2 84.85 404.98 84.85 Z"
        style="will-change: opacity, transform; fill: rgb(255, 255, 255);" id="o">
      <animate attributeName="visibility" values="hidden;visible;hidden" dur="4.05s" fill="freeze" calcMode="discrete"
               keyTimes="0; 0.22255; 1"/>
      <animate attributeName="opacity" values="0;1;1;0;0" dur="3.29s" fill="freeze"
               keyTimes="0; 0.17824; 0.6535; 0.83427; 1" calcMode="spline"
               keySplines="0.7 0 0.84 0; 0.7 0 0.84 0; 0.7 0 0.84 0; 0.7 0 0.84 0" begin="0.8s"/>
      <animateTransform type="translate" additive="sum" attributeName="transform" values="-250 0;0 0;0 0;-350 0;-250 0"
                        dur="4.21s" fill="freeze" keyTimes="0; 0.46318; 0.69834; 0.85986; 1" calcMode="spline"
                        keySplines="0.87 0 0.13 1; 0.5 0 0.75 0; 0.58 0.04 0.73 0.89; 0.5 0 0.75 0"/>
</path>
    <path
        d="M 554 100 L 519.82 62.26 L 517.1 62.26 C 512.29 62.26 506.91 62 500.96 61.72 L 500.96 100 L 479 100 L 479 3.67 C 484.6 2.56 490.75 1.67 497.48 1 C 504.2 0.35 510.79 0 517.25 0 C 534.74 0 547.75 2.48 556.32 7.45 C 564.88 12.41 569.15 20.26 569.15 30.95 C 569.15 38.29 566.85 44.38 562.25 49.2 C 557.64 54 550.92 57.51 542 59.67 L 579 100 L 554 100 Z M 500.96 47.65 C 506.85 48.18 512.55 48.45 518 48.45 C 528.53 48.45 536.2 47 541 44.27 C 545.86 41.48 548.29 37 548.29 31 C 548.29 26.88 547.26 23.51 545.22 20.99 C 543.18 18.45 540 16.59 535.76 15.44 C 531.49 14.29 525.92 13.71 519 13.71 C 513 13.71 507 14.19 500.96 15.18 L 500.96 47.65 Z"
        style="will-change: opacity, transform; fill: rgb(255, 255, 255);" id="r">
      <animate attributeName="visibility" values="hidden;visible;hidden" dur="4.31s" fill="freeze" calcMode="discrete"
               keyTimes="0; 0.28721; 1"/>
      <animate attributeName="opacity" values="0;1;1;0;0" begin="1.03s" dur="3.3s" fill="freeze"
               keyTimes="0; 0.22343; 0.60417; 0.78274; 1" calcMode="spline"
               keySplines="0.7 0 0.84 0; 0.7 0 0.84 0; 1 0 1 1; 0.7 0 0.84 0"/>
      <animateTransform type="translate" additive="sum" attributeName="transform" values="-250 0;0 0;0 0;-470 0;-300 0"
                        dur="4.33s" fill="freeze" keyTimes="0; 0.51963; 0.6836; 0.83603; 1" calcMode="spline"
                        keySplines="0.87 0 0.13 1; 0.55 0 1 0.45; 0.41 0 1 0.62; 0.55 0 1 0.45"/>
</path>
    <path
        d="M 681.69 100 L 618.11 100 L 600 100 L 636.74 0 L 663.29 0 L 700 100 L 681.69 100 Z M 618.11 100 L 681.69 100 L 649.88 11.36 L 618.11 100 Z"
        style="will-change: opacity, transform; fill: rgb(255, 255, 255);" id="a1">
      <animate attributeName="visibility" values="hidden;visible;hidden" dur="4.23s" fill="freeze" calcMode="discrete"
               keyTimes="0; 0.32704; 1"/>
      <animate attributeName="opacity" values="0;1;1;0;0" dur="2.77s" fill="freeze"
               keyTimes="0; 0.1977; 0.69153; 0.8231; 1" calcMode="spline"
               keySplines="0.7 0 0.84 0; 0.7 0 0.84 0; 1 0 1 1; 0.7 0 0.84 0" begin="1.34s"/>
      <animateTransform type="translate" additive="sum" attributeName="transform" values="-250 0;0 0;0 0;-600 0;-600 0"
                        dur="4.07s" fill="freeze" keyTimes="0; 0.62654; 0.73219; 0.88943; 1" calcMode="spline"
                        keySplines="0.87 0 0.13 1; 0.55 0 1 0.45; 0.46 0 1 0.33; 1 0 0.87 1"/>
</path>
</svg>`
    const placeholder = document.getElementById('logo-placeholder');
    const loader = document.getElementById('intro-overlay');
  });

  const removeLoader = () => {
    const intro = document.getElementById('intro-overlay');
    intro.style.transition = 'opacity .5s ease';
    setTimeout(() => {
      intro.style.opacity = '0'; // fade-out
      setTimeout(() => intro.remove(), 750); // detach from DOM
    }, 250);
  };

</script>
</body>

</html>
